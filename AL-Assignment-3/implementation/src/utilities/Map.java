/*Authors : Yulia Moshan 319565610
 * 			Gil Pasi 	 206500936
 * Algorithm planning - assignment 3 
 * */
package utilities;
import java.security.InvalidAlgorithmParameterException;
import java.util.ArrayList;
import java.util.List;

public class Map {
	//Equivalent to a graph

	String name = " ";
	private ArrayList<ArrayList<Path>> paths = new ArrayList<ArrayList<Path>>(); 
	private Coordinate [] coordinations;
	public ArrayList <Path> priorityList = new ArrayList<Path>();
	

	private int machineCount, pathCount; // == |V| , |E| respectively
	
	//----Constructors----
	public Map (int size) {
		this.machineCount = size;
		coordinations = new Coordinate [size];
		for(int i = 0 ; i < size ; i++) {
			//Add the actual edge
			paths.add(new ArrayList<Path>());
		}		
	}
	


	//----Accessors----
	public Coordinate getCoordinate (int machineIndex) {
		return coordinations[machineIndex];
	}
	
	public int getMachineCount() {return  machineCount;}
	public int getPathCount() {return  pathCount;}

	
	//Preserve encapsulation
	public ArrayList<ArrayList<Path>> getPaths (){return copyPaths(paths);}
	
	
	
	//================Algorithm methods(Accessors as well)=================
	
	
	
	//--------------------------------------------------------------------------
	//    Step 1: Find all graphs with |V|-1 edges based on the original graph
	//-------------------------------------------------------------------------
	
	
	public List<String> findPermutations() {
		/**The shortest/lightest journey must include all the branches.
		 * Meaning no less than |V| vertices. On the other hand it should aspire for
		 * the least amount of edges (paths) as possible.
		 * Therefore it must be a degenerated tree.
		 * This method focus on getting all possible trees permutations.
		 * A spanning tree / spanning map must have exactly |V| vertices and |V|-1 edges.
		 * The total amount of possible edges in an undirected graph is |V|*(|V|-1) / 2.
		 * This the reason for searching all the permutations of nPr while n = |V|*(|V|-1) / 2 , r = |V|-1 .
		 * */
		
		List<String> allPermutations = new ArrayList<String>();
		final int MAX_MAP_PATHS_COUNT = machineCount *(machineCount - 1) / 2;// V*(V-1) /2
		final int SPANNING_MAP_PATHS_COUNT = machineCount - 1;//V-1
		findPermutations(MAX_MAP_PATHS_COUNT,SPANNING_MAP_PATHS_COUNT, allPermutations, ""); 
		// A spanning tree must have precisely v - 1 paths
		return allPermutations;
	}
	
	
	public void findPermutations (int n , int r , List<String> pers , String curPer) {
		
		if(curPer.length() == n && countOnes(curPer) == r)
			pers.add(curPer);
		
		if(curPer.length() < n) {
			findPermutations(n, r, pers, curPer + "0");
			findPermutations(n, r, pers, curPer + "1");
		}
	}
	
	//-------------------------------------------------
	//    Step 2 : Convert the permutations to a map
	//-------------------------------------------------
	
	public Map stringToMap (String str ) {
		//Pyramid shape  for the paths : 0-1   0-2   0-3   0-4
		//									1-2   1-3   1-4
		//									   2-3   2-4
		//										  3-4
		
		
		Map ret = new Map(machineCount);
		ret.copyCoordinations(this);
		
		int currentMachine = 0;
		int neigborMachine = 1;

		//Scan the string
		for(char bit : str.toCharArray()) {
			if(bit == '1') {
				try {
					
					//Copy the coordinations properly == copy the weights properly
					ret.addPath(
							this.coordinations[currentMachine],
							this.coordinations[neigborMachine]);
					
				} catch (InvalidAlgorithmParameterException e) {
					e.printStackTrace();
				}
				
			}
			
			//According to the pyramid on top
			neigborMachine++;
			if(neigborMachine == machineCount) {
				currentMachine++;
				neigborMachine = currentMachine + 1;
			}
			
		}
				
		return ret;
	}
	
	//---------------------------------------------------------------------------------
	//    Step 3 : Filter all maps that are not degenerated (meaning they have circles)
	//----------------------------------------------------------------------------------
	
	public boolean isDegenerated () {
		/**This method finds out if a given map is a degenerated spanning tree.
		 * It does so by performing which resembles DFS. The only difference is 
		 * within the fact that there is no turning back once a vertex has been reached.
		 * Meaning a circle is not possible.At the end of the method it will check if any of the 
		 * vertices (machines) have not been visited , this is a sign of a non spanning tree.*/
		
		final int FIRST = 0 ;
		
		if(pathCount != machineCount - 1)return false;
		/*Less than v-1 vertices will result a graph that is not spanning the original graph.
		 * More than v-1 vertices will result necessarily a circle which is not degenerated by definition.*/
		
		
		ArrayList<ArrayList<Path>> leftpaths = copyPaths(paths);
		
		Path curPath = null;
		int curMachine = 0;
		boolean [] areVisited = new boolean [machineCount];

		//Find the first vertex
		for(int i = 0 ; i < leftpaths.size() ; i++) 
			if(!leftpaths.get(i).isEmpty()) {
				curPath = leftpaths.get(i).remove(FIRST);
				curMachine = i;
				areVisited[curMachine] = true;
				break;
			}

		
		//Scan from a vertex to his neighbors
		for(;;) {
			curMachine = inferNext(curPath, curMachine);
			
			//Do not visit a twice a vertex
			if(areVisited[curMachine] == true)
				return false;
			else 
				areVisited[curMachine] = true;
			
			removePath(curPath.getU(), curPath.getV(), leftpaths.get(curMachine));
			
			if(leftpaths.get(curMachine).isEmpty())
				break;
			
			else {
				curPath = leftpaths.get(curMachine).remove(FIRST);
			}
		}	
		
		//Final check
		for(ArrayList<Path> vertex : leftpaths)
			if(!vertex.isEmpty())return false;
		return true;
	}
	
	//--------------------------------------------------------------------
	//    Step 4 : Choose the lightest path , time-wise and priority-wise
	//--------------------------------------------------------------------
	
	
	/**The difference between "totalTime" and "totalWeight" methods lies on addressing the priority list.
	 *	The quickest journey is not necessarily the one that benefits the prioritized branches first.
	 *
	 *	Therefore the algorithm supplies the best weight algorithm (based on totalWeight) , with the 
	 *	matching time (based on totalTime)
	 * */
	
	
	public double totalTime () {
		double time = 0;		
		for (int i = 0 ; i < paths.size() ; i++)
			for(int j = 0 ; j < paths.get(i).size() ; j++) {
				
				time += paths.get(i).get(j).getTime();
			}
		
		/*Each edge is counted twice , one at the source vertex
		 *  and one at the destiny vertex.
		 *  Therefore eventually divide by 2.*/
		return time / 2;
	}
	
	public double totalWeight () {
		double weight = 0;
		final double PRIORITY_FACTOR = maxTime();
		
		for (int i = 0 ; i < paths.size() ; i++)
			for(int j = 0 ; j < paths.get(i).size() ; j++) {
				
				Path currentPath = paths.get(i).get(j);
				
				if(!priorityList.contains(currentPath))
					weight += PRIORITY_FACTOR + currentPath.getTime();
				else 
					weight += currentPath.getTime();
			}
		
		
		/*Each edge is counted twice , one at the source vertex
		 *  and one at the destiny vertex.
		 *  Therefore eventually divide by 2.*/
		return weight / 2;
	}
	
		

	
	public double maxTime () {
		double max = Double.MIN_VALUE;
		
		for (ArrayList<Path> currentMachine : paths) 
			for( Path currentPath : currentMachine)
				max = Math.max(currentPath.getTime(), max);
		
		return max;
	}
	
	//========================End of Algorithm===========================
	
	public String toString () {
		String ret = "Map" + name + ":\n";
		for(int i = 0 ; i < paths.size() ; i++) {
			ret += "(" + i + ")-[" ;
			for(int j = 0 ; j < paths.get(i).size() ; j++)
				ret += paths.get(i).get(j);
			
			ret+="]\n";
		}
		return ret;
	}
	
	//----Mutators----
	
	public void addPath (Coordinate v , Coordinate u) throws InvalidAlgorithmParameterException {
		//v == machine1, u == machine2 w == weight
		if(v.equals(u))
			throw new InvalidAlgorithmParameterException("No self paths");
		Path p = new Path(v , u );
		
		
		for(int i = 0  ;i < paths.size() ; i++)
			for(int j = 0 ; j < paths.get(i).size() ; j++)
				if(paths.get(i).equals(p))
					throw new InvalidAlgorithmParameterException("This edge already exists");

		
		/*Operation was not successful,
		 * a vertex v could not have more 
		 * then one edge to the another
		 *  vertex u*/
		paths.get(v.getIndex()).add(p);
		paths.get(u.getIndex()).add(p);
		pathCount++;
		
	}
	

	
	public void setCoordinate (int coordinateIndex , double x , double y , String city) {
		coordinations[coordinateIndex] =  new Coordinate(x , y ,coordinateIndex , city);
	}
	public void setCoordinate (Coordinate co) {
		coordinations[co.getIndex()] =  new Coordinate(co);
	}
	
	public void setCity (int cityIndex , String city) {
		coordinations[cityIndex].setCity(city);
	}
	
	public void copyCoordinations (Map other) {		
		//Avoid out of bound
		int minCopy = Math.min(this.machineCount, other.machineCount);
		
		for (int i = 0; i <  minCopy; i++) {
			double x = other.coordinations[i].getX();
			double y = other.coordinations[i].getY();
			String city = other.coordinations[i].getCity();
			setCoordinate(i, x , y , city);
		}
		
	}
	

	
	//----Class methods----
	public static double weight (double x1 , double x2 , double y1 ,  double y2 , String city1 ,String city2 ) {
		final double  EXTRA_SPEED = 70 , INTRA_SPEED  = 30 ,//kph
		FILL_TIME = 5,CITIES_TRANSFER_TIME = 6 ;//mins	
		
		
		double distance = Math.sqrt(
				Math.pow(x1 - x2 , 2) 
				+ 
				Math.pow(y1 - y1 , 2) 	
				);
		double time = 0;
		
		
		if(city1.equals(city2))
			time = distance / INTRA_SPEED + FILL_TIME;
		else 
			time = distance / EXTRA_SPEED + FILL_TIME + CITIES_TRANSFER_TIME;
		
		
		return time;
		
	}
	
	public static int countOnes (String str) {
		int counter = 0;
		for(char c : str.toCharArray())
			if(c == '1' )
				counter++;
		return counter;
	}
	
	public static ArrayList<ArrayList<Path>> copyPaths (ArrayList<ArrayList<Path>> original){
		ArrayList<ArrayList<Path>> copy = new ArrayList<>();
		
		for (ArrayList<Path> vertexpaths : original )
			copy.add(new ArrayList<Path>(vertexpaths));
		
		return copy;
		
	}
	
	public static int inferNext(Path path , int machine) {
		if(path.getU().getIndex() == machine)
			return path.getV().getIndex();
		else
			return path.getU().getIndex();
		
	}
	public static int inferPrevious(Path path , int machine) {
		if(path.getU().getIndex() == machine)
			return path.getU().getIndex();
		else
			return path.getV().getIndex();
		
	}
	
	public static void removePath (Coordinate v , Coordinate u , ArrayList<Path> list) {
		Path p = new Path(v , u);
		
		int i = 0 ;
		for(; i < list.size() ; i++) 
			if(list.get(i).equals(p)) {
				list.remove(i);
				i--;
			}
	}
	
}
